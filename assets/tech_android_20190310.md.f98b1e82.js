import{_ as e,c as p,o as t,a}from"./app.5b22e94d.js";const x=JSON.parse('{"title":"Android root 及应用安全评估","description":"","frontmatter":{"title":"Android root 及应用安全评估","date":"2019-03-10T00:00:00.000Z","draft":false,"tags":[2019,"Android"]},"headers":[],"relativePath":"tech/android/20190310.md"}'),o={name:"tech/android/20190310.md"},r=a("<p>Android root</p><p>在Android设备上，获得超级用户权限的过程被称为root，这个特殊账号拥有对UNIX系统所有文件与程序的权限，可以对操作系统完全控制。</p><p>NAND：计算机闪存设备，断电后仍能保持数据。</p><p>分区：设备的持久性存储内存中划分的逻辑存储单元或者块。</p><p>布局：对分区制定次序，偏移和尺寸。</p><p>不同设备的分区布局通常会不一样，但是一下几种都会存在：引导区，系统区，数据区，恢复区，缓存区。</p><p>确定分区布局：1，查看/proc文件系统中partitions条目的内容。2，检查/dev/block/platform中SoC特定目录的内容，在by-name目录下，每个分区名都被链接到相应的块设备上。3，/etc/vold.fstab文件，恢复日志，以及内核日志。4，mount命令查看/proc/mounts。</p><p>下载模式：引导加载程序都支持将手机设置为下载模式，这种模式下，能够让用户在底层更新手机的持久性存储，这个过程通常被称为刷机。通过在启动时按住特定的组合键，启动下载模式，等待PC通过USB进行连接，PC和引导加载程序之间通过设备支持的下载协议进程通信，包括冲刷NAND分区，设备重启，下载与执行替换内核映像等。</p><p>解锁引导加载程序：在fastboot模式下，使用fastboot oem unlock。</p><p>恢复模式：特定的按键组合或者通过adb reboot recovery命令。</p><p>应用安全评估</p><p>普通性安全问题：</p><p>应用权限问题，当前Android权限模型粒度下，开发者往往会申请比实际应用所需更多的权限，导致权限执行与文档描述不一致。权限申请不足，通常会导致可靠性或功能性问题，严重的情况下可能会导致应用崩溃，过度的权限申请如果被恶意应用所攻击，则会导致权限提升的问题。</p><p>敏感数据的不安全传输，弱机密或者不加密，强加密但缺少安全警告或者证书验证错误处理，在安全协议失效以后使用明文，在不同网络类型的传输安全使用上不一致。</p><p>不安全的数据存储，Android为数据存储提供了很多标准支持，包括共享配置文件，SQLite数据库，和原始文件。最普遍的是对敏感数据明文存储，未受保护的content provider接口，以及不安全的文件权限。</p><p>日志信息泄露，日志是信息泄露的主要途径，开发者对日志的滥用，可能会导致日志记录下普通的诊断消息，登录凭证或者其他敏感信息。</p><p>不安全的IPC端点，通常进程间通信的端点包括，Service,Activity,Broadcast Reciver,Content Provider。content provider在设计上暴露了对结构化数据的访问，可能会遭遇目录遍历或者注入攻击。Activity,作为面向用户的组件，可能会被恶意应用进行界面伪装攻击。Broadcast Reciver经常用于处理隐式Intent，或者系统范围事件。Service是应用进行后台处理的组件，类似于Broadcast Reciver，Activity,与Service的交互是使用Intent完成的，包括，启动，绑定。停止等动作。绑定后的Service可能会向其他应用暴露出与应用相关的另一层次的功能，可能会导致一个任意命令执行的漏洞。</p><p>隐式Intent指那些没有指明特定目标组件的Intent。</p><p>静态分析</p><p>使用apktool工具，apktool d xxx.apk，解码apk的内容。</p><p>使用androguard，androlyze提供了一个IPython shell。AnalyzeAPK方法表示创建APK,资源，与dex代码的恰当对象并添加一个使用dad反编译器的选项。就可以把dex码转为java伪码。</p><p>androlyze.py -s</p><p>a,d,dx=AnalyzeAPK(&quot;/xxx/xxx/xxx.apk&quot;,decompiler=&quot;dad&quot;)</p><p>你得到的三个对象是a一个APK对象，d一个DalvikVMFormat对象数组和dx一个Analysis对象</p><p>a.permissions 用来检查权限。</p><p>a.get_permissions() 获取APK的权限.。</p><p>a.get_activities() 获取AndroidManifest.xml中定义的所有活动的列表。</p><p>a.get_package() 获取包名称</p><p>a.get_app_name()获取包应用程序名称</p><p>a.get_app_icon()取包图标路径</p><p>a.get_androidversion_code() 获取数字版本</p><p>a.get_androidversion_name() 获取版本字符串</p><p>a.get_min_sdk_version() 获取最小SDK版本</p><p>a.get_max_sdk_version() 获取最大SDK版本</p><p>a.get_target_sdk_version() 获取目标SDK版本</p><p>a.get_effective_target_sdk_version() 获取有效的SDK版本</p><p>a.get_android_manifest_axml().get_xml() 获取AndroidManifest.xml的解码XML</p><p>a.get_services()检查Service</p><p>a.get_recivers()查看应用中Broadcast Reciver</p><p>在analyze中调用目标方法的show函数，可以对方法进行反汇编以了解调用该方法会发生什么，对同一方法调用其source函数，可以对方法进行反汇编，获得一个可读性更高的版本，将直接回复出Java代码。</p><p>使用d.create_xref()创建交叉引用，然后调用方法的show_xref()函数，查看方法的交叉引用(xref)。</p><p>详见androguard使用。</p><p>动态分析</p><p>动态分析需要运行应用，通常会在插装或者监控的方式下进行，以获取关于应用的具体行为信息。</p><p>Andbug，连接到Java调试连线协议端点上，可以在应用的manifest文件中显示的标注，android:debuggable=true,让应用开放Android调试桥（adb）端点。</p><p>攻击</p><p>见Drozer使用。</p>",47),d=[r];function n(i,s,_,c,v,l){return t(),p("div",null,d)}const A=e(o,[["render",n]]);export{x as __pageData,A as default};
