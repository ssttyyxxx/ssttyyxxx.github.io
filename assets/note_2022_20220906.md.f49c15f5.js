import{_ as t,c as p,o as e,a}from"./app.5b22e94d.js";const T=JSON.parse('{"title":"昨天是我的生日","description":"","frontmatter":{"title":"昨天是我的生日","date":"2022-09-06T00:00:00.000Z","draft":false,"tags":[2022,"生日"]},"headers":[],"relativePath":"note/2022/20220906.md"}'),_={name:"note/2022/20220906.md"},o=a("<p>我所涉猎的技术并不多，但是也不少，依我看，技术确实在趋向一个词，那就是内卷。技术已经不再是单纯的创造力工具，而是沦为瓜分市场的武器，哪里有竞争，哪里就有内卷，技术也是一种竞争，更不用说传说中的鄙视链。</p><p>我想大多数人都是一样，人云亦云而已，他们并不是真的用过那些技术，深刻的思索过背后的原因，只是听过别人说，或者一种直观的感觉去判断，哪种技术好，那种技术不好，排斥某种技术，狂热于某种技术。</p><p>当然我也是，我尤其不喜欢java，因为每次当我搜索什么解决办法的时候，冒出来的答案Java都会来插上一脚，在我搜之前，内心其实已经有了一个模糊的答案，所以这算是出现了意料之外的答案，因此我愤恨，这个哪里都要冒一头的人，像个热心急躁的小伙子，哪里都想试试；还有一种情况，也是我讨厌Java的原因，就是Java好像被什么组织给支配了，到处都是培训班，视频教程，框架教程，点进去看，无非就是那几个培训机构出的，讲的冗长乏味，全是稀碎的东西，我立马关掉。我不需要谁教我从头写hello，world，只是想要一种解决问题的办法，他们做不到，只是自顾自的讲那些讲了千百遍的内容，所以我讨厌。</p><p>技术市场又多大点地盘，其实并不多，现在分的已经很细了，个个领域都有合适的解决方案，但是并不是每个人都能解决个个领域的问题，于是又出现了一个问题，技术能解决问题，但是人解决不了。所以世面上的那些教程，只是说这个工具该怎么用，而不教问题该怎么解决，这工具该怎么使用，还需要人教吗？说明书，就是最好的教程。那些教程，属于无用功，各种名词描述的天花乱坠，他们已经偏离了技术的主旨，不在聚焦于解决问题，而是聚焦于如何获取流量，赚更多的钱。这点他们确实是很成功的，因为再倔强的顾客也经不住千篇一律的菜单，还是会下单的。</p><p>我不信任别人写的东西，又或者我觉得别人写的东西不好，不适合我，想要改造，于是我会动手，自己去实现，这是我的内部驱动力，也是我搞技术的原因，因为能够创造，能够改变。</p><p>我之前学操作系统，只是走马观花，大学课堂也只是在恍惚间度过，没学到什么东西，又好像学到了什么，那是什么呢？一种视野，知道存在。然后在工作的过程中，遇到问题了，基于之前的视野，然后去寻找这种存在意义，和为什么，这是一种往复，更是一种学习方式，因为我是基于体验的学习方式，如果让我空想，很难明白其</p><p>中的缘由，只有去探索和体验，才能获得知识。其他的像网络原理，计算机组成原理，算法等等，都是这样的感觉，学的时候留一个坑洞，到了用的时候，再去补上，用的越多，填的越满。</p><p>所以我不明白那些空谈理论的教程有什么用，估计连空洞都不会留下，毕竟谁也不会记住教室后排窗台洒下的阳光和旁边的朋友。</p><p>技术是有一个从上而下的结构的，这个结构当中，越向上越远离硬件，越向下越接近真相，所以在我的意识里，真相是被埋藏在最底下的，因此我常常溯源，想要找的一个问题的终极答案，有的时候能找到，有的时候找不到，因此也不得不感叹，知识的匮乏是限制个人发展的枷锁。硬件上有操作系统，负责调度硬件的各种资源，这个操作系统又因为硬件的不同而不同，因为不同的硬件对于资源的操作需要使用不同的指令，所以操作系统这里需要解决的问题是适配各种硬件和资源调度的问题，操作系统上有各种软件，有图形化的，也有非图形化的，负责计算的，负责存储的，总体来说，计算机就是这两种功能，计算和存储，计算人们不能轻易计算的结果，然后把计算结果展示出来，如果想要下次不计算，那就要把计算结果存储下来，这就是存储的意义。到了软件层面，花活就更多了，有虚拟机，可以让一个代码的软件在各个操作系统中运行，因为虚拟机负责翻译代码把结果进行统一处理，所以这个虚拟机在一些层面也扮演着操作系统的角色。除了虚拟机，还有编译器，这个就厉害了，这个会把代码编译成可运行文件，然后也可以在各个操作系统中运行，他和虚拟机的区别就是，目标系统不需要编译器，但是会需要虚拟机。还有一种软件，是虚拟化技术所催生出来的软件，这类软件利用硬件的虚拟化技术，可以虚拟化一个系统出来，现在的云技术，就是以此为基石的，当然也可以在虚拟的操作系统里再虚拟操作系统，这种操作是没有意义的，除了证明这东西很有趣，没啥意义，因为每次虚拟都会使用资源，这些资源都是由最终的硬件提供的，不可能超出这个硬件的限制，只会造成无端的资源浪费。</p><p>软件最重要的指标是什么？在我看来是性能，单位时间里所能做的事情，当然事情的正确度同样重要。现在的技术，是一层接着一层网上嵌套的，一方面肯定是为了节省开发的时间，另一方面则是为了具象，更加接近人类的思考习惯，所以才有面向对象，面向切面，面向过程这些东西，具象出来的东西越简单，说明下面埋藏的细节越多，这种简单会让人懒惰，同样还会让程序员思维固化，不求尝试其他的更好的解决办法。最重要的问题，每嵌套一层，都面临着性能的损耗，因为每多一层调用，就会多这一层调用的性能使用，所以层级越高，性能就会越差。</p><p>现在框架真的是太多了，也太简单了，这让很多人认为程序开发就是那么简单的事情，这确实有好处，快速的开发出来，解决问题不好吗？当然是好事，只不过，这里面埋藏着很多问题，如果不深入研究，遇到问题会无法解决，因为很多程序框架，一开始都是为了解决特定问题而产生的，并不是普遍适用的，所以换个问题，可能不会有那么高的解决效率。</p><p>所以，在我看来，技术实际面临的时候如何更好的解决问题，这个更好，是个很坑的词，因为评判的依据不定，有短时间能解决问题的，可以称作更好，有使用更少资源的，也可以称作更好，还有人，更熟悉某个技术，也可以称为更好。因此在解决问题之前，最好先弄清楚问题，然后再选用适于自己的技术，才是更好的选择。</p><p>关于技术生涯，其实是没有尽头的，因为技术层出不穷，硬件资源现在也是越来越便宜了，所以上层技术真实日新月异，俗话说的卷，就是这样，我能做的，我要做的更好，我不能做的，我要尝试去做，好像每个技术都想把所有领域都霸占，那这样，其他技术的意义何在呢？我不明白，是不是因为向下发展到了尽头，所以只能向上挣扎。</p>",13),s=[o];function r(n,c,d,i,l,f){return e(),p("div",null,s)}const h=t(_,[["render",r]]);export{T as __pageData,h as default};
