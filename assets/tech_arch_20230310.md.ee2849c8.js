import{_ as e,c as a,o as l,a as i}from"./app.5b22e94d.js";const k=JSON.parse('{"title":"设计原则","description":"","frontmatter":{"title":"设计原则","date":"2023-03-10T00:00:00.000Z","draft":false},"headers":[{"level":2,"title":"高内聚 低耦合","slug":"高内聚-低耦合","link":"#高内聚-低耦合","children":[]},{"level":2,"title":"分离关注点","slug":"分离关注点","link":"#分离关注点","children":[]},{"level":2,"title":"面向对象","slug":"面向对象","link":"#面向对象","children":[]},{"level":2,"title":"高级原则","slug":"高级原则","link":"#高级原则","children":[{"level":3,"title":"开放/关闭原则","slug":"开放-关闭原则","link":"#开放-关闭原则","children":[]},{"level":3,"title":"里氏替换原则","slug":"里氏替换原则","link":"#里氏替换原则","children":[]},{"level":3,"title":"依赖倒置原则","slug":"依赖倒置原则","link":"#依赖倒置原则","children":[]}]},{"level":2,"title":"设计模式","slug":"设计模式","link":"#设计模式","children":[{"level":3,"title":"设计模式","slug":"设计模式-1","link":"#设计模式-1","children":[]}]},{"level":2,"title":"依赖注入","slug":"依赖注入","link":"#依赖注入","children":[]}],"relativePath":"tech/arch/20230310.md"}'),t={name:"tech/arch/20230310.md"},d=i('<h1 id="设计原则" tabindex="-1">设计原则 <a class="header-anchor" href="#设计原则" aria-hidden="true">#</a></h1><blockquote><p>完美的设计部署包罗万象无所不有，而是完整自洽不可精简</p></blockquote><h2 id="高内聚-低耦合" tabindex="-1">高内聚 低耦合 <a class="header-anchor" href="#高内聚-低耦合" aria-hidden="true">#</a></h2><p>高内聚表示某个特定的软件模块——无论是子程序，一个类型还是一个类库，都应该完成一系列极为相关的功能。</p><p>类似于化学中分子之间的吸引力。</p><p>内聚的标准从高到低，内聚越高说明软件设计的越好。</p><p>高内聚意味着高可维护行和可重用行，因为这些模块的外部依赖很少。</p><p>耦合用来度量两个软件模块之间的依赖程度，如果修改样A模块的同时也要修改B模块，那么这两个模块就是耦合的。</p><p>低耦合并不是说腻的模块应该与其他模块完全隔绝，模块之间应该通信，不过应该依赖于设计良好且不易改变的接口。</p><h2 id="分离关注点" tabindex="-1">分离关注点 <a class="header-anchor" href="#分离关注点" aria-hidden="true">#</a></h2><p>分离关注点的核心在于将系统拆分成各个不相同且最好没有重叠的功能。每个系统中的功能表示一个关注点，一次只处理一个关注点，并不是说把其他关注点抛弃，而是从这个模块的角度考虑，其他关注点都是不相关的。</p><p>模块化和信息隐藏。</p><p>模块只有公开接口暴露的成员才能被其他模块使用。</p><p>信息隐藏是指使用度过的公开接口因此软件模块的实现细节。</p><h2 id="面向对象" tabindex="-1">面向对象 <a class="header-anchor" href="#面向对象" aria-hidden="true">#</a></h2><p>找到合适的对象，尽量降低耦合，保证代码重用。</p><h2 id="高级原则" tabindex="-1">高级原则 <a class="header-anchor" href="#高级原则" aria-hidden="true">#</a></h2><h3 id="开放-关闭原则" tabindex="-1">开放/关闭原则 <a class="header-anchor" href="#开放-关闭原则" aria-hidden="true">#</a></h3><p>模块应该对扩展开发，对修改关闭。</p><p>再面向对象中，最好的方式是提供固定接口，然后让所有可能发生变化的类实现该接口。</p><h3 id="里氏替换原则" tabindex="-1">里氏替换原则 <a class="header-anchor" href="#里氏替换原则" aria-hidden="true">#</a></h3><p>当某个类派生自某个现有类型时，派生类型应该能够用于任何可以使用到父类的地方，就是多态。</p><p>换句话，子类可以替代基类使用。</p><h3 id="依赖倒置原则" tabindex="-1">依赖倒置原则 <a class="header-anchor" href="#依赖倒置原则" aria-hidden="true">#</a></h3><p>高层次的组件不应该依赖于低层次的组件，二者都应依赖于接口。</p><p>抽象不应该依赖于细节，细节应该依赖于抽象。</p><p>原则中的倒置，表示在实现过程中，应该采用自顶向下的方式，且应该关注于高层次此模块的工作流，而不是低层次模块的具体实现。</p><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-hidden="true">#</a></h2><p>模式用于解决方案中两个侧面上：实现，架构。由此引申出两种模式，设计模式和架构模式。</p><h3 id="设计模式-1" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式-1" aria-hidden="true">#</a></h3><p>一种设计模式就是一个已知且被广泛关注的核心解决方案，适用于解决一类实现过程中出现的专门的问题。</p><p>首先应该有问题，再从设计模式中选择一种模式来尝试解决。</p><h2 id="依赖注入" tabindex="-1">依赖注入 <a class="header-anchor" href="#依赖注入" aria-hidden="true">#</a></h2><p>控制反转和依赖注入可以认为时同义词，不过在字面上不是同义词，控制反转是指原则，而依赖注入则代表了原则的应用。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>“简单是一切之本”这句话也叫做KISS（KeepSimple,Stupid）。</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>不要重复你自己（n、Repeat№刘f，DRY）：指降低应用程序中的重复，且建 议对于同样的信息，仅在一个位置存放·</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>一次且仅一次（“andlyOnce，OAOO）：指降低同一个应用程序中编写同样 代码的次数·</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>你不会用到它（YouArentGonnaNeedlt，YAGNI）：指仅当不可避免需要且没有 其他解决办法时，再向程序中添加新功能·</p></div>',38),r=[d];function h(c,p,s,n,o,u){return l(),a("div",null,r)}const b=e(t,[["render",h]]);export{k as __pageData,b as default};
