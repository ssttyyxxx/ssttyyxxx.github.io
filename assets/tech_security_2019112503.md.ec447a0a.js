import{_ as t,c as e,o as p,a as _}from"./app.5b22e94d.js";const l=JSON.parse('{"title":"一谈安全测试","description":"","frontmatter":{"title":"一谈安全测试","date":"2019-11-25T00:00:00.000Z","draft":false,"tags":[2019,"安全测试"]},"headers":[],"relativePath":"tech/security/2019112503.md"}'),a={name:"tech/security/2019112503.md"},s=_("<p>最近在考虑换工作的事情，对我而言目前有两条路可以走，即安全测试和渗透测试。</p><p>接到了一些安全测试的面试，也接到了一些渗透测试的面试，但是面试下来，发现安全测试与渗透测试还是有很大的区别的。</p><p>下面就个人经验谈一下安全测试，以及与渗透测试的区别。</p><p>根据搜到的资料，安全测试是在产品研发周期内，保证产品安全性的测试活动，而渗透测试是通过模拟黑客恶意行为，来评估产品安全性的活动。</p><p>形象比喻，安全测试更像是盾，而渗透测试更像是矛。安全测试侧重与产品的防御能力提升，渗透测试侧重与找出产品的弱点。两者并没有明显的优势与劣势，更不存在好坏之分，都是为了保证产品的安全。</p><p>重点说安全测试，因为安全测试是贯穿于整个产品生命周期，所以通常能够拿到源码，，设计说明书等，所以更容易发现产品的安全问题。</p><p>从威胁分析的角度讲，可以从六个维度进行安全测试活动：仿冒，伪造，篡改，拒绝服务，权限提升，信息泄露。</p><p>具体来讲，仿冒，对于Web形态的产品而言，常见的攻击手段如中间人攻击，会话劫持等，对于APP形态的产品，不仅有中间人攻击，会话劫持，还有可能造成APP被篡改，仿冒产品本身。防御中间人攻击的手段目前最有效的还是使用安全通道，防止被中间人攻击，客户端与服务端校验对端证书，协商加密通道的方法。对于会话劫持，这个不能做到安全防御，但是可以做到尽量消减威胁，通过服务器端校验会话，设置会话有效期，服务器端及时清理会话消息，达到消减威胁的目的。对于APP，如果要防止被仿冒，一方面是要对APP进行签名，同时在APP打开或者发送重要的时候，校验APP的签名信息，通过与服务的预制的签名信息进行校验，防止APP被仿冒。</p><p>伪造，主要的攻击手段是，伪造身份信息，伪造恶意请求，伪造会话信息等。身份信息可以通过服务端身份校验，权限控制校验进行防范，恶意请求可以通过服务端严格校验客户端接受的消息，包括参数类型，参数长度，空值等等。会话信息的伪造，可以通过使用随机数来生产会话id，认证凭证，且必须大于24bit，也就是192byte，防止被猜解出来。</p><p>篡改，主要包括篡改消息请求，篡改本地数据，篡改数据流。请求消息可以通过加密传输的方式，防止被篡改。本地数据，可以通过在使用数据前，校验数据哈希值，以防止使用被篡改的数据。篡改数据流，可以通过，加强参数校验，严格校验每个参数类型，大小，长度，防止被恶意数据注入，造成拒绝服务。</p><p>拒绝服务，最常用的两种，一种是对频繁发送大量请求，以消耗系统资源，造成服务挂死，还有一种是延迟拒绝服务攻击，通常是在发送一个在请求头或者请求体中加入\\r\\n的请求消息，当服务器接收到请求时，会以为这条消息没有接收完，会一直等待接收消息，再发送请求的时候，服务器还处于等待上个报文结束状态，造成拒绝服务，后者成本要求很低，而且不易察觉。第一种的防范手段，可以通过限制同一IP请求发送速度，一旦速度达到某个值，就停止处理该IP发送的消息，第二种可以通过校验请求头和请求体内容的方式，如果有\\r\\n，就替换掉，或者不继续接收请求。</p><p>权限提升，常用方法包括OS注入，SQL注入，横向越权，纵向越权等。对于OS注入，防范手段包括过滤特殊的命令行字符，或者不使用外部输入作为系统运行时参数，SQL注入防范手段包括过滤特殊字符和SQL关键字，使用预编译手段执行SQL语句。横向越权和纵向越权，通过对权限进行严格控制，对每个系统角色的权限和可以使用的资源严格控制，确保权限最小化。</p><p>信息泄露，是近几年频发的安全事件，这里的信息是指系统的敏感信息，个人数据，账号信息，配置信息，数据库信息等。消息泄露可能会因为任何一个微小的漏洞而产生，因此重点讲如何保护这些消息。敏感信息，通过密码算法进行加密，重要请求走加密通道传输，个人信息，账号信息，配置信息，如果本地存储，一定要加密存储，且使用安全的加密算法，最好是在服务器端加密存储，数据库信息泄露，主要源自SQL注入，在数据库操作中，如果要使用外部参数，一定要严格过滤参数，特殊符号和关键字，也可以用预编译，占位符的方式，重要的信心加密存储。推荐使用的是AES和RSA加密算法。前者是对称加密算法，目前CBC模式，GCM模式，CTR模式，OFB模式，CFB模式，都还相对安全，密钥长度最少128位；后者是非对称加密算法，采用公钥加密，私钥解密，私钥一定要保护好，可以通过加密保存，分层保存等。</p><p>谈了这么多，全都是一时兴起，不知从何而起，从何而知，我知道关键在于我的安全体系还不够健全，不够清晰，还请见谅。</p>",14),r=[s];function c(o,n,P,i,d,S){return p(),e("div",null,r)}const f=t(a,[["render",c]]);export{l as __pageData,f as default};
