import{_ as e,c as t,o as r,a}from"./app.5b22e94d.js";const v=JSON.parse('{"title":"MYSQL拾遗","description":"","frontmatter":{"title":"MYSQL拾遗","date":"2023-03-09T00:00:00.000Z","draft":false},"headers":[],"relativePath":"tech/mysql/20230309.md"}'),n={name:"tech/mysql/20230309.md"},o=a("<p>视图是一些复用查询语句的封装，由基本表产生，操作视图的数据会修改基本表的数据</p><p>触发器，当表中的数据发生改变时，自动去执行的处理。</p><p>delete，insert，update</p><p>create trigger trigger_name before|after| trigger_event on table_name fro each row trigger_stmt</p><p>create trigger trigger_name before|after trigger_event on table_name for each row begin trigger_stmt end</p><p>stmt 是需要执行的操作 begin和end之间是多条执行语句</p><p>delimiter $$ ... $$ delimiter;</p><hr><p>insert into table(fd1,fd2,fd3...) values(va1,va2,va3...)</p><p>insert into table(fd1,fd2,fd3...) values(va1,va2,va3...),(va1,va2,va3...),(va1,va2,va3...)</p><p>insert into table (fd1,fd2,fd3...) select (fd1,fd2,fd3...) from table where</p><hr><p>update table set fd1=va1,fd2=va2,fd3=va3 where condition</p><p>不加where则是全部更新</p><hr><p>delete from table where condition</p><p>不加where则是全部删除</p><hr><p>union 把相同字段数目和字段类型的表合并到一起</p><p>迪卡尔积，没有连接条件表关系的返回的结果，字段是几张表字段的总和和，数据是几张表数据的积</p><p>join 在表关系的迪卡尔积中按照相应字段的值比较条件进行选择生成一个新的关系。</p><p>inner join outter join cross join</p><p>inner join 内连接，在笛卡尔积中保留所有匹配的数据记录，舍弃不匹配的记录。</p><p>自然连接，等值连接，不等连接（交集，并集，反集）</p><p>outter join 不仅保留匹配的数据，还保留部分不匹配的数据</p><p>left outter join，保留左边表中不匹配的数据 right outter join，保留右边表中不匹配的数据 full outter join，保留左右两边不匹配的数据</p><p>select fd1,fd2,fd3... from table1 innner join table2 on join_condition</p>",27),p=[o];function i(d,f,s,_,l,c){return r(),t("div",null,p)}const g=e(n,[["render",i]]);export{v as __pageData,g as default};
