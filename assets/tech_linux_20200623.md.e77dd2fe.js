import{_ as e,c as t,o as p,a as n}from"./app.5b22e94d.js";const j=JSON.parse('{"title":"Linux内核架构学习笔记 三","description":"","frontmatter":{"title":"Linux内核架构学习笔记 三","date":"2020-06-23T00:00:00.000Z","draft":false,"tags":[2020,"Linux"]},"headers":[],"relativePath":"tech/linux/20200623.md"}'),c={name:"tech/linux/20200623.md"},o=n(`<p>1，内核通过缓存来改进系统性能，由于内核是基于页的内存映射来实现访问块设备的，因此也按页组织，故称页缓存。</p><p>2，块缓存用于缓存没有组成成页的数据，重要性差很多，传统UNIX上，块缓存用作系统主缓存，Linux已经由页缓存取代了。</p><p>3，内核提供的标准链表可以用于任何数据结构彼此链接起来，它不是类型安全的，加入链表的数据结构必须包含一个类型为list_head的成员，其中包含了正向和反向指针。</p><p>4，链表七点同样是list_head实例，使用LIST_HEAD宏声明和初始化</p><p>5，循环链表的时间复杂的为O(1)</p><p>6，作为数据结构的成员struct_list_head被称作链表元素，链表起点元素被称作表头。</p><p>7，一般性内核对象机制可用于执行的对象操作：</p><pre><code> 引用计数

 管理对象链表

 集合加锁

 将对象属性导出到用户空间（通过sysfs文件系统）
</code></pre><p>8，kobject不是通过指针与其他数据结构连接起来，而是必须直接嵌入。通过管理kobject即可达到对包含kobject对象的管理。</p><p>9，kobject结构成员语义：</p><p>k_name——对象的文本名称，可以利用sysfs导出到用户空间。</p><p>kref——类型为struct kref，用于简化引用计数的管理。</p><p>entry——标准的链表元素，用于将若干kobject放置到一个链表中。</p><p>kset——将对象与其他对象放置到一个集合时使用</p><p>parent——是以一个指向父对象的指针，用于在kobject之间建立层次结构</p><p>ktype——提供包含kobject的数据结构详细信息，最重要的事用于释放该数据结构资源的析构器函数</p><p>10，kobject与面向对象编程语言的对象概念相似，提供了在内核使用面向对象技术的可能性，无需C++的额外机制。</p><p>11，kref中只有refcount，refcount是一个院子数据类型，给出内核中当前使用某个对象的计数，计数器为0时，就可以从内存中删除。</p><p>12，处理kobject的标准方法：</p><pre><code>kobject_get()，kobject_put()——对kobject的引用计数器加1或减1

kobject_(un)register()——从层次结构中注册或删除对象，对象被添加到父对象中显存的集合kset中，同时在sysfs文件系统中创建一个对应项。

kobject_init()——初始化一个kobject，将引用计数器设置为初始值，初始化对象的链表元素

kobject_add()——初始化一个内核对象，并使之显示在sysfs中

kobject_cleanup()——，在不需要kobject时，释放分配的资源
</code></pre><p>13，如果某个变量的类型时typedef而来，则不能直接访问，而需要通过辅助函数。</p><p>14，内核定义了若干整数数据类型，不仅明确是有符号还是无符号，而且还指定了相关类型的精确位数。</p><p>15，字节序——现代计算机采用大端序或者小端序格式。在大端序中，最高有效字节存储在最低地址，随着地址升高，字节的权重降地；小端序中，最低有效字节存储在最低地址，而随着地址升高，诶姐的权重也升高。</p><p>16，基本数据类型的结构取决于底层体系结构的字节序。</p><p>17，内核提供各种函数和宏，可以在CPU使用的格式和特定的表示法之间转换。</p><p>18，内核的严肃问题：</p><pre><code>调 试 内 核 通 常 要 比 调 试 用 户 层 程 序 困 难。

内核提供许多辅助函数，类似于C语言库，但是内核中的东西总是朴素的多

用户层程序错误可能会导致段错误，或者内存转储，但是内核错误会导致整个系统故障。

需要考虑到内核运行在许多体系结构上根本不支持非对齐内存访问。

所有的内核代码必须并发安全。

内核代码必须在大端序和小端序计算机上都可以运行。

大多数体系结构不允许在内核中执行浮点运算，因此需要想办法用整型替代。
</code></pre>`,27),s=[o];function _(r,a,k,d,i,f){return p(),t("div",null,s)}const u=e(c,[["render",_]]);export{j as __pageData,u as default};
