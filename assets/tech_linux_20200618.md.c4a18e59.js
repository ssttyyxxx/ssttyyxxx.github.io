import{_ as p,c as e,o as t,a as i}from"./app.5b22e94d.js";const u=JSON.parse('{"title":"Linux内核架构学习笔记 二","description":"","frontmatter":{"title":"Linux内核架构学习笔记 二","date":"2020-06-18T00:00:00.000Z","draft":false,"tags":[2020,"Linux"]},"headers":[],"relativePath":"tech/linux/20200618.md"}'),a={name:"tech/linux/20200618.md"},s=i("<p>1，内存映射是一种重要的抽象手段，内核中大量使用，也可以用于用户程序。映射方法把任意来源的数据传输到进程的虚拟地址空间中，作为映射目标的地址空间区域，可以像普通内存那样访问，任何修改都会自动传输到原数据源。、</p><p>2，内存在实现设备驱动程序时直接使用了内存映射，外设的输入/输出可以映射到虚拟地址空间区域中。</p><p>3，内核在分配内存的时候，必须记录页帧的已分配状态或空闲状态，以避免两个进程使用相同的内存区域。</p><p>4，内存分配和释放非常的频繁，为了保证尽快完成，内核还可以只分配完整的页帧，用户空间中的标准库将内存划分为更小的区域，并为进程分配内存。</p><p>5，内核有时候需要分配连续页，为了快速检测连续区域，使用一种古老的技术——伙伴系统。</p><p>6，系统中的空闲内存总是两两分组，每组中的两个内存块成为伙伴，伙伴的分配是彼此独立的，但是如果两个伙伴都空闲出来，内核就会将其合并为一个更大的内存块,，作为下一层次上某个内存块的伙伴。</p><p>7，应用程序释放内存时，内核直接检查地址，判断是否可以创建一组伙伴，并合并为一个更大的内存块，放到伙伴聊表中，这是内存块分裂的逆向过程。</p><p>8，在系统的长期运行过程中，频繁的分配和释放页帧可能会导致一种情况，就是若干空闲页帧散布在物理空间的各处，也就是系统缺乏连续页帧组成的较大内存块——称为碎片的内存管理问题。</p><p>9，内核本身经常需要比完整页帧小的多的内存块，但内核无法使用标准库函数，必须在伙伴系统的基础上进行额外的内存管理，将页划分为更小的部分，这样不仅可以分配内存，还可以为频繁使用的小对象实现一个一般性缓存——slab缓存。</p><p>10，对频繁使用的对象，内核定义了只包含了所需类型对象实例的缓存，slab缓存自动维护与伙伴系统的交互，在缓存用尽时请求刷新页帧。</p><p>11，对通常情况下的小内存块分配，内核针对不同大小的对象定义了一组slab缓存，可以像用户空间编程一样，使用相同的函数访问这些缓存，不同的事函数前缀加了看，表明是与内核相关联的：kmalloc，kfree</p><p>12，页帧由伙伴系统分配，slab分配器负责分配小内存块及提供一般性内核缓存。</p><p>13，通过利用磁盘空间作为扩展内存，从而增大可用内存。内核需要更多内存时，不经常使用的页可以写入硬盘，需要访问相关数据时，内核再将相应的页换回内存——页面交换。</p><p>14，换出的页孔毅通过特别的页表项标识，进程试图访问此类页帧时，CPU会启动一个可以被内核截取的缺页异常，此时内核可以将硬盘上的数据切换到内存中，接下来用户进程恢复运行。——缺页异常机制</p><p>15，页面回收——用于将内存映射被修改的内容与底层的块设备同步，也简称数据回写。数据刷出后，内核即可将页帧用于其他用途。</p><p>16，内核必须能够测量时间以及不同时间点的时差，进程调度就会用到这个功能。jiffies_64和jiffies分别对应64位和32位系统的全局变量，按照恒定的时间间隔递增。</p><p>17，每种计算机的底层体系结构都提供了一些执行周期性操作的手段，通常的形式是定时器中断。</p><p>18，jiffies的递增频率与体系结构有关，取决于内核中的主要常数HZ。该数值通常介于100和1000中间。换言之，jiffies的值每秒递增次数在100到1000此之间。</p><p>19，jiffies的计时相对粒度较粗，在底层硬件允许的条件下，内核可以使用高分辨率的定时器来提供额外的计时手段，以纳秒级的精确度和分辨率来计量时间。</p><p>20，系统调用时用户进程与内核交互的经典仿佛。POSIX标准定义了许多系统调用，以及这些系统调用在所有遵从POSIX的系统包括Linux上的语义。</p><p>21，传统的系统调用按不同类别分组：进程管理，信号，文件，目录和文件系统，保护机制，定时器函数。</p><p>22，详细说明：</p><p>进程管理：创建新进程，查询信息，调试</p><p>信号：发送信号，定时器以及相关处理机制</p><p>文件：创建，打开，和关闭文件，从文件读取以及向文件写入，查询信息和状态。</p><p>目录和文件系统：创建，删除和重命名目录，查询信息，连接，变更目录</p><p>保护机制：读取和变更UID/GID，命名空间的处理。</p><p>定时器函数：定时器函数和统计信息。</p><p>23，外设分为两类：字符设备，块设备。</p><p>24，字符设备：提供连续的数据流，应用程序可以顺序读取，不支持随即存取。调制解码器是典型的字符设备。</p><p>25，块设备：应用程序可以随即访问设备数据，自行确定读取数据的位置，数据的读取只能以块（512B）为单位，不支持基于字符的寻址。硬盘是典型的块设备。</p><p>26，网卡也可以通过驱动程序控制，但是在内核中属于特殊状况，因为网卡不能利用设备文件访问。</p><p>27，为了支持通过文件接口处理网络连接，Linux使用了源于BSD的套接字抽象。套接字可以看作是应用程序，文件接口，内核的网络实现只见的代理。</p><p>28，Linux由成百上千的文件组成，数据存储在硬盘或者其他块设备。存储使用了层次式文件系统。</p><p>29，内核提供一个额外的软件层，将底层文件系统具体特征与应用层隔离开来，称为——VFS，既是向上的接口也是向下的接口。</p><p>30，模块用于在运行时动态的向内核添加功能，如驱动程序，文件系统，网络协议等，实际上内核的任何子系统都可以模块化。</p><p>31，模块的本质不过是普通的程序，只是在内核空间运行而不是在用户空间执行而已。</p><p>32，模块必须提供某些代码在初始化和终止时执行（init.text和exit.text），以便向内核注册和注销模块。模块代码可以编译到内核代码中，访问内核中的所有数据和函数。</p>",38),_=[s];function n(o,c,r,f,l,d){return t(),e("div",null,_)}const m=p(a,[["render",n]]);export{u as __pageData,m as default};
